{"ast":null,"code":"class WebSocketService {\n  // callbacks Dictionary use for new messages commands\n  static getInstance() {\n    if (!WebSocketService.instance) {\n      WebSocketService.instance = new WebSocketService();\n    }\n\n    return WebSocketService.instance;\n  }\n\n  constructor() {\n    this.callbacks = {};\n    this.socketRef = null;\n  }\n\n  connect(chatUrl) {\n    const path = `ws://127.0.0.1:8000/ws/chat/${chatUrl}/`;\n    console.log(path);\n    this.socketRef = new WebSocket(path);\n\n    this.socketRef.onopen = () => {\n      console.log('websocket open');\n    }; //        this.socketNewMessage(JSON.stringify({\n    //            command: 'fetch_messages'\n    //        }))\n\n\n    this.socketRef.onmessage = e => {\n      // Sending a message\n      this.socketNewMessage(e.data);\n    };\n\n    this.socketRef.onerror = e => {\n      console.log(e.message);\n    };\n\n    this.socketRef.onclose = () => {\n      console.log('websocket is closed');\n      this.connect();\n    };\n  }\n\n  disconnect() {\n    this.socketRef.close();\n  }\n\n  socketNewMessage(data) {\n    // Read an object as JSON File\n    const parsedData = JSON.parse(data); // If fetch message or new message, then\n    // grabing this command, and terminate if the commands\n    // then we are going to handle all those messages\n    // coming through, and new message handle as new message\n\n    const command = parsedData.command; // If Object.keys callbacks, then it goes to 'callbacks = {};'\n\n    if (Object.keys(this.callbacks).length === 0) {\n      return;\n    }\n\n    if (command === 'messages') {\n      this.callbacks[command](parsedData.messages);\n    }\n\n    console.log(this);\n\n    if (command === 'new_message') {\n      /// Problem Area\n      this.callbacks[command](parsedData.message);\n    }\n\n    console.log(this);\n  } // Pass through admin.\n  // Add chatID parameter that fetch_messages chatID passed it.\n\n\n  fetchMessages(username, chatId) {\n    this.sendMessage({\n      command: 'fetch_messages',\n      username: username,\n      chatId: chatId\n    });\n    console.log(chatId);\n    console.log(username);\n  }\n\n  newChatMessage(message) {\n    this.sendMessage({\n      command: 'new_message',\n      from: message.from,\n      message: message.content,\n      chatId: message.chatId\n    });\n    console.log(message);\n  } // Basically parsed in the names of functions to actually be called\n  // when theses callbacks tlace or these commands are taking place.\n\n\n  addCallbacks(messagesCallback, newMessageCallback) {\n    this.callbacks['messages'] = messagesCallback;\n    this.callbacks['new_message'] = newMessageCallback;\n  }\n\n  sendMessage(data) {\n    try {\n      this.socketRef.send(JSON.stringify({ ...data\n      }));\n    } catch (err) {\n      console.log(err.message);\n    }\n  }\n\n  state() {\n    return this.socketRef.readyState;\n  } // It has Timeout function, and Chat.js importing this function.\n  // Basically ensure that we wait for the connection to be steady.\n  // Call this the wait for socket connection method.\n\n\n  waitForSocketConnection(callback) {\n    const socket = this.socketRef;\n    const recursion = this.waitForSocketConnection; // It can maintain connected conditions.\n\n    setTimeout( // Set Times by seconds milliseconds.\n    function () {\n      if (socket.readyState === 1) {\n        console.log('connection is secure'); // if didn't pass in a callback,\n        // then call the callback.\n\n        if (callbacks != null) {\n          callback();\n        } // Otherwise will just return.\n\n\n        return;\n      } else {\n        console.log('waiting for connection...');\n        recursion(callback);\n      }\n    }, 1);\n  }\n\n} // Call Method 'getInstance()' which is static.\n\n\nWebSocketService.instance = null;\nconst WebSocketInstance = WebSocketService.getInstance();\nexport default WebSocketInstance;","map":{"version":3,"sources":["E:/Django/Django_Channels/Team_Project/Django_Channels_New_Version/src/websocket.js"],"names":["WebSocketService","getInstance","instance","constructor","callbacks","socketRef","connect","chatUrl","path","console","log","WebSocket","onopen","onmessage","e","socketNewMessage","data","onerror","message","onclose","disconnect","close","parsedData","JSON","parse","command","Object","keys","length","messages","fetchMessages","username","chatId","sendMessage","newChatMessage","from","content","addCallbacks","messagesCallback","newMessageCallback","send","stringify","err","state","readyState","waitForSocketConnection","callback","socket","recursion","setTimeout","WebSocketInstance"],"mappings":"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","sourcesContent":["class WebSocketService {\r\n\r\n    static instance = null;\r\n    // callbacks Dictionary use for new messages commands\r\n    callbacks = {};\r\n\r\n    static getInstance() {\r\n        if(!WebSocketService.instance){\r\n            WebSocketService.instance = new WebSocketService();\r\n        }\r\n        return WebSocketService.instance;\r\n    }\r\n\r\n    constructor() {\r\n        this.socketRef = null;\r\n    }\r\n\r\n    connect(chatUrl) {\r\n        const path = `ws://127.0.0.1:8000/ws/chat/${chatUrl}/`;\r\n        console.log(path);\r\n        this.socketRef = new WebSocket(path);\r\n        this.socketRef.onopen = () => {\r\n            console.log('websocket open');\r\n        };\r\n//        this.socketNewMessage(JSON.stringify({\r\n//            command: 'fetch_messages'\r\n//        }))\r\n        this.socketRef.onmessage = e => {\r\n            // Sending a message\r\n            this.socketNewMessage(e.data);\r\n        }\r\n        this.socketRef.onerror = e => {\r\n            console.log(e.message);\r\n        }\r\n        this.socketRef.onclose = () => {\r\n            console.log('websocket is closed');\r\n            this.connect();\r\n        }\r\n    }\r\n\r\n    disconnect() {\r\n        this.socketRef.close();\r\n    }\r\n\r\n    socketNewMessage(data){\r\n        // Read an object as JSON File\r\n        const parsedData = JSON.parse(data);\r\n        // If fetch message or new message, then\r\n        // grabing this command, and terminate if the commands\r\n        // then we are going to handle all those messages\r\n        // coming through, and new message handle as new message\r\n        const command = parsedData.command;\r\n        // If Object.keys callbacks, then it goes to 'callbacks = {};'\r\n        if(Object.keys(this.callbacks).length === 0){\r\n            return;\r\n        }\r\n        if(command === 'messages'){\r\n            this.callbacks[command](parsedData.messages);\r\n        }\r\n        console.log(this);\r\n        if(command === 'new_message'){\r\n            /// Problem Area\r\n            this.callbacks[command](parsedData.message);\r\n        }\r\n        console.log(this);\r\n    }\r\n\r\n    // Pass through admin.\r\n    // Add chatID parameter that fetch_messages chatID passed it.\r\n    fetchMessages(username, chatId){\r\n        this.sendMessage({\r\n            command: 'fetch_messages',\r\n            username: username,\r\n            chatId: chatId\r\n        });\r\n        console.log(chatId);\r\n        console.log(username);\r\n    }\r\n\r\n\r\n    newChatMessage(message){\r\n        this.sendMessage({\r\n            command: 'new_message',\r\n            from: message.from,\r\n            message: message.content,\r\n            chatId: message.chatId\r\n        });\r\n        console.log(message);\r\n    }\r\n\r\n    // Basically parsed in the names of functions to actually be called\r\n    // when theses callbacks tlace or these commands are taking place.\r\n    addCallbacks(messagesCallback, newMessageCallback){\r\n        this.callbacks['messages'] = messagesCallback;\r\n        this.callbacks['new_message'] = newMessageCallback;\r\n    }\r\n\r\n    sendMessage(data){\r\n        try{\r\n            this.socketRef.send(JSON.stringify({ ...data }))\r\n        } catch (err){\r\n            console.log(err.message);\r\n        }\r\n    }\r\n\r\n    state() {\r\n        return this.socketRef.readyState;\r\n    }\r\n\r\n    // It has Timeout function, and Chat.js importing this function.\r\n    // Basically ensure that we wait for the connection to be steady.\r\n    // Call this the wait for socket connection method.\r\n    waitForSocketConnection(callback){\r\n        const socket = this.socketRef;\r\n        const recursion = this.waitForSocketConnection;\r\n        // It can maintain connected conditions.\r\n\r\n        setTimeout(\r\n            // Set Times by seconds milliseconds.\r\n            function(){\r\n            if (socket.readyState === 1){\r\n                console.log('connection is secure');\r\n                // if didn't pass in a callback,\r\n                // then call the callback.\r\n                if(callbacks != null){\r\n                    callback();\r\n                }\r\n                // Otherwise will just return.\r\n                return;\r\n            } else {\r\n                console.log('waiting for connection...');\r\n                recursion(callback);\r\n            }\r\n        }, 1);\r\n    }\r\n}\r\n\r\n// Call Method 'getInstance()' which is static.\r\nconst WebSocketInstance = WebSocketService.getInstance();\r\n\r\nexport default WebSocketInstance;\r\n"]},"metadata":{},"sourceType":"module"}