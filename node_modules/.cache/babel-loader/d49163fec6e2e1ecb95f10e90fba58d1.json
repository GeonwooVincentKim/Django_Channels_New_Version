{"ast":null,"code":"import _objectSpread from\"C:\\\\Users\\\\Adminstrator\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\react-scripts\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";import _classCallCheck from\"C:\\\\Users\\\\Adminstrator\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\react-scripts\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";import _createClass from\"C:\\\\Users\\\\Adminstrator\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\react-scripts\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";var WebSocketService=/*#__PURE__*/function(){_createClass(WebSocketService,null,[{key:\"getInstance\",// callbacks Dictionary use for new messages commands\nvalue:function getInstance(){if(!WebSocketService.instance){WebSocketService.instance=new WebSocketService();}return WebSocketService.instance;}}]);function WebSocketService(){_classCallCheck(this,WebSocketService);this.callbacks={};this.socketRef=null;}_createClass(WebSocketService,[{key:\"connect\",value:function connect(chatUrl){var _this=this;var path=\"ws://127.0.0.1:8000/ws/chat/\".concat(chatUrl,\"/\");console.log(path);this.socketRef=new WebSocket(path);this.socketRef.onopen=function(){console.log('websocket open');};//        this.socketNewMessage(JSON.stringify({\n//            command: 'fetch_messages'\n//        }))\nthis.socketRef.onmessage=function(e){// Sending a message\n_this.socketNewMessage(e.data);};this.socketRef.onerror=function(e){console.log(e.message);};this.socketRef.onclose=function(){console.log('websocket is closed');_this.connect();};}},{key:\"disconnect\",value:function disconnect(){this.socketRef.close();}},{key:\"socketNewMessage\",value:function socketNewMessage(data){// Read an object as JSON File\nvar parsedData=JSON.parse(data);// If fetch message or new message, then\n// grabing this command, and terminate if the commands\n// then we are going to handle all those messages\n// coming through, and new message handle as new message\nvar command=parsedData.command;// If Object.keys callbacks, then it goes to 'callbacks = {};'\nif(Object.keys(this.callbacks).length===0){return;}if(command==='messages'){this.callbacks[command](parsedData.messages);}console.log(this);if(command==='new_message'){/// Problem Area\nthis.callbacks[command](parsedData.message);}console.log(this);}// Pass through admin.\n// Add chatID parameter that fetch_messages chatID passed it.\n},{key:\"fetchMessages\",value:function fetchMessages(username,chatId){this.sendMessage({command:'fetch_messages',username:username,chatId:chatId});console.log(chatId);console.log(username);}},{key:\"newChatMessage\",value:function newChatMessage(message){this.sendMessage({command:'new_message',from:message.from,message:message.content,chatId:message.chatId});console.log(message);}// Basically parsed in the names of functions to actually be called\n// when theses callbacks tlace or these commands are taking place.\n},{key:\"addCallbacks\",value:function addCallbacks(messagesCallback,newMessageCallback){this.callbacks['messages']=messagesCallback;this.callbacks['new_message']=newMessageCallback;}},{key:\"sendMessage\",value:function sendMessage(data){try{this.socketRef.send(JSON.stringify(_objectSpread({},data)));}catch(err){console.log(err.message);}}},{key:\"state\",value:function state(){return this.socketRef.readyState;}// It has Timeout function, and Chat.js importing this function.\n// Basically ensure that we wait for the connection to be steady.\n// Call this the wait for socket connection method.\n},{key:\"waitForSocketConnection\",value:function waitForSocketConnection(callback){var socket=this.socketRef;var recursion=this.waitForSocketConnection;// It can maintain connected conditions.\nsetTimeout(// Set Times by seconds milliseconds.\nfunction(){if(socket.readyState===1){console.log('connection is secure');// if didn't pass in a callback,\n// then call the callback.\nif(callbacks!=null){callback();}// Otherwise will just return.\nreturn;}else{console.log('waiting for connection...');recursion(callback);}},1);}}]);return WebSocketService;}();// Call Method 'getInstance()' which is static.\nWebSocketService.instance=null;var WebSocketInstance=WebSocketService.getInstance();export default WebSocketInstance;","map":{"version":3,"sources":["E:/Django/Django_Channels/Team_Project/Django_Channels_New_Version/src/websocket.js"],"names":["WebSocketService","instance","callbacks","socketRef","chatUrl","path","console","log","WebSocket","onopen","onmessage","e","socketNewMessage","data","onerror","message","onclose","connect","close","parsedData","JSON","parse","command","Object","keys","length","messages","username","chatId","sendMessage","from","content","messagesCallback","newMessageCallback","send","stringify","err","readyState","callback","socket","recursion","waitForSocketConnection","setTimeout","WebSocketInstance","getInstance"],"mappings":"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","sourcesContent":["class WebSocketService {\r\n\r\n    static instance = null;\r\n    // callbacks Dictionary use for new messages commands\r\n    callbacks = {};\r\n\r\n    static getInstance() {\r\n        if(!WebSocketService.instance){\r\n            WebSocketService.instance = new WebSocketService();\r\n        }\r\n        return WebSocketService.instance;\r\n    }\r\n\r\n    constructor() {\r\n        this.socketRef = null;\r\n    }\r\n\r\n    connect(chatUrl) {\r\n        const path = `ws://127.0.0.1:8000/ws/chat/${chatUrl}/`;\r\n        console.log(path);\r\n        this.socketRef = new WebSocket(path);\r\n        this.socketRef.onopen = () => {\r\n            console.log('websocket open');\r\n        };\r\n//        this.socketNewMessage(JSON.stringify({\r\n//            command: 'fetch_messages'\r\n//        }))\r\n        this.socketRef.onmessage = e => {\r\n            // Sending a message\r\n            this.socketNewMessage(e.data);\r\n        }\r\n        this.socketRef.onerror = e => {\r\n            console.log(e.message);\r\n        }\r\n        this.socketRef.onclose = () => {\r\n            console.log('websocket is closed');\r\n            this.connect();\r\n        }\r\n    }\r\n\r\n    disconnect() {\r\n        this.socketRef.close();\r\n    }\r\n\r\n    socketNewMessage(data){\r\n        // Read an object as JSON File\r\n        const parsedData = JSON.parse(data);\r\n        // If fetch message or new message, then\r\n        // grabing this command, and terminate if the commands\r\n        // then we are going to handle all those messages\r\n        // coming through, and new message handle as new message\r\n        const command = parsedData.command;\r\n        // If Object.keys callbacks, then it goes to 'callbacks = {};'\r\n        if(Object.keys(this.callbacks).length === 0){\r\n            return;\r\n        }\r\n        if(command === 'messages'){\r\n            this.callbacks[command](parsedData.messages);\r\n        }\r\n        console.log(this);\r\n        if(command === 'new_message'){\r\n            /// Problem Area\r\n            this.callbacks[command](parsedData.message);\r\n        }\r\n        console.log(this);\r\n    }\r\n\r\n    // Pass through admin.\r\n    // Add chatID parameter that fetch_messages chatID passed it.\r\n    fetchMessages(username, chatId){\r\n        this.sendMessage({\r\n            command: 'fetch_messages',\r\n            username: username,\r\n            chatId: chatId\r\n        });\r\n        console.log(chatId);\r\n        console.log(username);\r\n    }\r\n\r\n\r\n    newChatMessage(message){\r\n        this.sendMessage({\r\n            command: 'new_message',\r\n            from: message.from,\r\n            message: message.content,\r\n            chatId: message.chatId\r\n        });\r\n        console.log(message);\r\n    }\r\n\r\n    // Basically parsed in the names of functions to actually be called\r\n    // when theses callbacks tlace or these commands are taking place.\r\n    addCallbacks(messagesCallback, newMessageCallback){\r\n        this.callbacks['messages'] = messagesCallback;\r\n        this.callbacks['new_message'] = newMessageCallback;\r\n    }\r\n\r\n    sendMessage(data){\r\n        try{\r\n            this.socketRef.send(JSON.stringify({ ...data }))\r\n        } catch (err){\r\n            console.log(err.message);\r\n        }\r\n    }\r\n\r\n    state() {\r\n        return this.socketRef.readyState;\r\n    }\r\n\r\n    // It has Timeout function, and Chat.js importing this function.\r\n    // Basically ensure that we wait for the connection to be steady.\r\n    // Call this the wait for socket connection method.\r\n    waitForSocketConnection(callback){\r\n        const socket = this.socketRef;\r\n        const recursion = this.waitForSocketConnection;\r\n        // It can maintain connected conditions.\r\n\r\n        setTimeout(\r\n            // Set Times by seconds milliseconds.\r\n            function(){\r\n            if (socket.readyState === 1){\r\n                console.log('connection is secure');\r\n                // if didn't pass in a callback,\r\n                // then call the callback.\r\n                if(callbacks != null){\r\n                    callback();\r\n                }\r\n                // Otherwise will just return.\r\n                return;\r\n            } else {\r\n                console.log('waiting for connection...');\r\n                recursion(callback);\r\n            }\r\n        }, 1);\r\n    }\r\n}\r\n\r\n// Call Method 'getInstance()' which is static.\r\nconst WebSocketInstance = WebSocketService.getInstance();\r\n\r\nexport default WebSocketInstance;\r\n"]},"metadata":{},"sourceType":"module"}